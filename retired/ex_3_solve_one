from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit import execute
from qc_grader import prepare_ex3, grade_ex3
import numpy as np

problem_set = [
    [["0", "2"], ["1", "0"], ["1", "2"], ["1", "3"], ["2", "0"], ["3", "3"]],
    [["0", "0"], ["0", "1"], ["1", "2"], ["2", "2"], ["3", "0"], ["3", "3"]],
    [["0", "0"], ["1", "1"], ["1", "3"], ["2", "0"], ["3", "2"], ["3", "3"]],
    [["0", "0"], ["0", "1"], ["1", "1"], ["1", "3"], ["3", "2"], ["3", "3"]],
    [["0", "2"], ["1", "0"], ["1", "3"], ["2", "0"], ["3", "2"], ["3", "3"]],
    [["1", "1"], ["1", "2"], ["2", "0"], ["2", "1"], ["3", "1"], ["3", "3"]],
    [["0", "2"], ["0", "3"], ["1", "2"], ["2", "0"], ["2", "1"], ["3", "3"]],
    [["0", "0"], ["0", "3"], ["1", "2"], ["2", "2"], ["2", "3"], ["3", "0"]],
    [["0", "3"], ["1", "1"], ["1", "2"], ["2", "0"], ["2", "1"], ["3", "3"]],
    [["0", "0"], ["0", "1"], ["1", "3"], ["2", "1"], ["2", "3"], ["3", "0"]],
    [["0", "1"], ["0", "3"], ["1", "2"], ["1", "3"], ["2", "0"], ["3", "2"]],
    [["0", "0"], ["1", "3"], ["2", "0"], ["2", "1"], ["2", "3"], ["3", "1"]],
    [["0", "1"], ["0", "2"], ["1", "0"], ["1", "2"], ["2", "2"], ["2", "3"]],
    [["0", "3"], ["1", "0"], ["1", "3"], ["2", "1"], ["2", "2"], ["3", "0"]],
    [["0", "2"], ["0", "3"], ["1", "2"], ["2", "3"], ["3", "0"], ["3", "1"]],
    [["0", "1"], ["1", "0"], ["1", "2"], ["2", "2"], ["3", "0"], ["3", "1"]],
]


def convert_problem_set_to_binary(ps: list):

    ps_binary = list()

    for row in ps:
        row_binary = ["0" for n in range(16)]
        for pair in row:
            # Convert pair to binary location:
            location = int(pair[0]) * 4 + int(pair[1])
            row_binary[location] = "1"

        row_binary = "".join(row_binary)
        ps_binary.append(row_binary)

    print(ps_binary)


def data_loader(qc, qr_data_row, qr_data_col, qr_data_state, problem):

    for i, pair in enumerate(problem):
        binary_str = "{0:03b}".format(i)

        # Encode address bits
        for j in range(3):
            if binary_str[j] == "0":
                qc.x(qr_addr[j])

        # Remove encode address bits
        for j in range(3):
            if binary_str[j] == "0":
                qc.x(qr_addr[j])

        # 6 qubits for state???


def oracle():
    pass


def diffusion():
    pass


def week3_ans_func(problem_set):
    # Build your quantum circuit here
    # In addition, please make it a function that can solve the problem even with different inputs (problem_set). We do validation with different inputs.

    problem = convert_problem_set_to_binary(problem_set)[1]

    qr_shot = QuantumRegister(8)
    qr_data_row = QuantumRegister(2)
    qr_data_col = QuantumRegister(2)
    qr_data_state = QuantumRegister(1)
    qr_addr = QuantumRegister(3)

    cr = ClassicalRegister(8)

    qc = QuantumCircuit(qr_shot, qr_data, cr)

    qc = data_loader(qc, qr_data_row, qr_data_col, qr_data_state, qr_addr, problem)

    # Code for Grover's algorithm with iterations = 1 will be as follows.
    for i in range(1):
        oracle()
        diffusion()

    return qc


if __name__ == "__main__":

    qc = week3_ans_func(problem_set)

